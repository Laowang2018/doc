类 
	抽象笼统的概念 描述一类事物 肯定是具有相同的特征行为
对象
	具体的一个类中的一个个体 类中衍生出来的一个具体的个体 
	应该与自己的类具有相同的特征和行为

父类----子类	
总结，继承只能覆盖方法，而不能覆盖成员变量，若有同名变量，则相互独立，直接获取时依据对象类型，调用时依据方法定义在哪个类中。



类成员变量
	成员变量初始化比代码块早
	访问权限 [特征修饰] 变量类型 变量名 [= 变量内容];
	public String name = "laowang";
	变量初始化的次序 是按照 定义的前后顺序
方法
	overload重载 方法名相同 方法的参数列表不同:参数个数不同，参数类型不同，参数顺序不同
	可变参数列表：可变参数后不能再有参数，且可变参数仅有一个 public void test(int... x){} x其实就是int类型数组
	访问权限 [特征修饰] 返回类型 方法名()[{}];    如果没有返回用void关键字
	public void test(){}

代码块
	和方法一样 做事情的
	代码块也需要调用才能执行 我们自己调用不到（没有名字）
	在构造方法执行前，成员变量初始化后执行
	{}

构造方法
	每一个类都有构造方法，若不定义，系统会默认提供构造方法（无参构造方法），
	若在类中自己定义构造方法，则默认的无参构造方法即被覆盖
	只能用来创建当前类对象
	要用new关键字来调用
	可以抛出异常
	与类同名的方法，不用返回值类型（因为返回类型已确定为某类对象），可以有参数，方法体必须有。
	可以重载overload
	
	
this关键字
	
	有参构造方法内执行无参构造方法或其他构造方法： this(); this(参数1，参数2)
	this在类中表示当前对象 this可以出现在任何位置





成员代码块，成员变量，构造方法，静态代码块，执行顺序：
静态代码块(父) > 静态代码块(子) > 实例成员变量(父) > 构造代码块(父) > 构造方法(父) > 实例成员变量(子) > 构造代码块(子) > 构造方法(子)

静态变量 和 static修改的静态代码块 运行的顺序是根据代码编写的先后









需求：写一个计算器程序(模拟计算器)
	  写一个数组工具可以操作数组的工具类ArrayBox