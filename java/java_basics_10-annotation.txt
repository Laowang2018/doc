    注释：
    单行注释 //
    多行注释 /* */
    文档注释 /** */

注解：
    写法
        @XXX[(一些信息)]
    注解放置在哪里
        类的上面 属性的上面 方法上面 构造方法上面 参数前面
    注解的作用
        用来充当注释的作用（仅仅是一个文字说明） @Deprecated
        用来做代码的检测（验证） @Override
        可以携带一些信息（内容）
    java中有一些写好的注解供我们使用
        @Deprecated 用来说明方法是废弃的
        @Override 用来做代码检测的 检测方法是否是一个重写方法
        @SuppressWarnings({"unused"}) 抑制代码生成warning 如果只有一个元素大括号可以不写
            unused 变量定义后未被使用
            serial 类实现了序列化接口 不添加序列化ID号
                private static final long serialVersionID = 1L;
            rawtypes 集合没有定义泛型
            deprecation 方法已废弃
            unchecked 出现了泛型问题 可以不检测
            all 包含了以上所有（不推荐）

    注解中可以携带信息 可以携带
        信息不能随意写 信息的类型只能是如下类型
            基本数据类型
            String类型
            枚举类型enum
            注解类型@
            数组类型[] 数组的内部需要是如上的四种类型
    自己描述一个注解类型
        通过@interface创建一个注解类型
        发现写法与接口非常相似（可以利用接口的特点来记忆注解）
            可以描述public static final的属性（这种用法比较少见）
            可以描述public abstract 方法  （注解方法要求必须有返回值 但类型固定）
        我们自己定义的注解如果想要拿来使用
            光定义还不够 还需要做很多细致的说明（需要利用Java提供好的注解来说明）
            元注解（也是注解，不是拿来使用的 是用来说明注解的）
                @Target 用来描述当前的这个注解可以用在哪个位置
                @Retention 描述当前的这个注解存在什么作用域中的
                    源代码文件 --> 编译--> 字节码文件 --> 加载--> 内存执行
                @Inherited 描述当前这个注解是否能被子类对象继承 它没有其他信息
                @Document 描述这个注解是否能被文档所记录 它没有其他信息

            使用自己定义的注解
                问题：在注解里面描述的一个方法 方法没有参数 方法是有返回值String[]
                    使用注解的时候 让我们传递参数
                    理解为 注解的方法做事 将我们传递给他的参数 搬运走了 给了别人
                问题：使用别人的写好的注解不用写方法名 我们自己定义的方法必须写名字
                    如果我们自己定义的注解 只有一个方法 方法名字叫value
                    在使用的时候就可以省略方法名
                    如果传递的信息是一个数组 数组内只一个元素 可以省略{}
                    如果方法是两个以上 每一个方法必须写名字
    如何解析注解内携带的信息（反射机制）
        使用注解给对象注入属性值
        spring中对注解的使用和对注解解析
        注解和xml配置

    注解应用场景
        配置 属性注入


Properties类 它一个HashTable的子类 是一个map类型的集合 用来读取文件中的信息----流
    Properties props = new Properties();
    props.load(new FileReader("src/path"));