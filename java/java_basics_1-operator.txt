Java运算符
	运算符 用来指明对于操作数的运算方式
	
	分类
		按照操数的数目来进行分类
		单目 双目 三目
		a++  a+b  (a>b)?x:y;
		
		按照运算符的功能来进行分类
		算术运算 + - * / %（取余 取模）++ -- 
			int x = 1;int y = x++;
			x在想要做值交换的时候 会产生一个临时的副本空间（备份）
			++在变量的前面 先自增后备份 ++在变量的后面 先备份后自增
			会将副本空间的内的值赋给别人
			int a = 1;
			a = a++;//先备份(a 1)到(a' 1) 后自增(a 2),把(a' 1)再赋值给(a 2) 用1把2给覆盖了 所以a==1; 
			a == 1;//true
			
			int a = 1;
			for(int i=1; i<=100; i++){
				a = a++;
			}
			a == 1;//true
			
			int m = 1;// 2 1 0
			int n = 2;// 3 2 1
			int sum = m+++++n-n-----m+n-----m;
			int sum = 	   m++ + ++n - n-- - --m + n-- - --m;
				sum = 		1  +  3  - 3  -  1 +  2  -   0
						
		赋值运算 = 将=号右边的内容（值 引用）存入=左边的变量空间内
				+= -= *= /= %=
				byte x = 1;
				x += 2;//3
				x = x + 2;//编译出错
				+和= 都可以自动类型提升
				=号后面是表达式（x+2）时没法自动类型提升
				+= 是一个运算符也能自动类型提升但是如果右面表达式带有变量且不确定时没法自动类型提升
				
		关系运算（比较）
		< <= > >= 仅支持两个操作数是数值类型
		== != 支持操作数是数值类型型和引用类型
			==与equals() ==比较的是值或者地址 equals()是一个Object对象方法，可以被重写，如果没有重写本质就是==
		instanceof 比较一个对象是否属于一个类的类型的
		关系运算的结果是boolean型
		
		逻辑运算
		连接的是两个boolean型 结果也是boolean型
		& | ^ ! && || 
		^异或 同样时才为真 不同时为假
		
		位bit运算
		用来计算二进制的
		3 & 5
		& | ^ ~ << >> >>>
		二进制 01
		十进制 0123456789
		八进制 01234567  034
		十六进制 0123456789ABCDEF 0X3B
		~6 取反 取反是一个计算过程（每一个位置都取反）
		正数的原码 反码 补码都是一样的 
		负数的原码 取反得反码（全部取反 不包括符号位） 反码+1得补码
		计算机中不管是正数还是负数 存储的形式都是以补码的形式来存储的
						6                                    -6
		00000000 00000000 00000000 00000110   10000000 00000000 00000000 00000110 原码
		00000000 00000000 00000000 00000110   11111111 11111111 11111111 11111001 反码 符号位不动 其余取反
		00000000 00000000 00000000 00000110   11111111 11111111 11111111 11111010 补码 反码+1
		
		注意 反码是种表现形式（负数的反码 符号位是不变的） 取反是一个计算过程（每一个位置都取反）
		
		6<<1 == 12  6<<2 == 24 相当于乘以2的位移次幂
		6>>1 == 3   6>>2 == 1  相当于除以2的位移次幂
		>>保留符号位置1 填1(负数补1 正数补0)
		>>>不保留符号 不管是什么 都填0
		-6>>1  符号位补1 有符号位移
		11111111 11111111 11111111 11111010
		111111111 11111111 11111111 1111101
		-6>>>1  符号位补0 无符号位移
		11111111 11111111 11111111 11111010
		011111111 11111111 11111111 1111101
		~10 ----> -11 取反
		00000000 00000000 00000000 00001010 源码 反码 补码都一样
		11111111 11111111 11111111 11110101 取反 ----是负的（负数转成源码 -1 取反）
		11111111 11111111 11111111 11110100 -1
		10000000 00000000 00000000 00001011 取反（符号位不动）-11
		
		
		~(-11)
		10000000 00000000 00000000 00001011 -11原码
		11111111 11111111 11111111 11110100 反码
		11111111 11111111 11111111 11110101 补码 -11在存储的样子
		00000000 00000000 00000000 00001010 取反运算 得10
		
		两个变量交换：
		方式一：
		int a = 1;
		int b = 2;
		int c;
		c = a;
		a = b;
		b = c;
		多占用一个变量空间
		方式二：
		int a = 1;
		int b = 2;
		a = a + b;
		b = a - b;
		a = a - b;
		a + b容易超出int范围
		方式三：
		int a = 1;
		int b = 2;
		a = a ^ b;
		b = a ^ b;
		a = a ^ b;
		
		
笔试题：
	& 与 && 的区别
		&可视为逻辑运算符  也可视为位运算符 
		&&只能当作逻辑运算符用
		
		如果两个符号都当作逻辑运算符来使用的时候 
		&前后两个条件都是true 最终结果就是true
		&&短路与 正常情况下与&执行结果是一致的
			当前面条件为false的时候 发生短路 最终结果false
	
	最有效率的方式计算2*8的结果 
	
		2 << 3;
		
	交换两个变量的值进行交换
		方式一：
		int a = 1;
		int b = 2;
		int c;
		c = a;
		a = b;
		b = c;
		容易理解 值不会出现问题 多占用一个变量空间 
		
		方式二：
		int a = 1;
		int b = 2;
		a = a + b;
		b = a - b;
		a = a - b;
		省略了一个栈空间  相对不易理解  a + b容易超出int范围产生越界
		
		方式三：
		int a = 1;
		int b = 2;
		a = a ^ b;
		b = a ^ b;
		a = a ^ b;
		
		最不易理解