类和类之间的关系：
	A is-a B 			泛化(继承 实现)					
	A has-a B           包含(组合 聚合 关联)
	A use-a B (A need a B)   依赖(依赖)
	
继承
	子类  父类 
	子类继承父类，通过关键字 extends
	子类的对象可以调用父类中的(public protected)属性和方法 当作自己的来使用
	子类可以添加自己独有的属性和方法的
	子类从父类中继承过来的方法不能满足子类需求，可以在子类中重写（覆盖）父类中的方法 更多指的是方法内容上重写
				方法重写override                 方法重载overload
		1.类	产生两个继承关系的类			一个类中的一组方法
				子类重写父类的方法	
		2.权限	子类可以大于等于父类			没有要求
		3.特征  final static abstract   		没有要求
				父类方法是final 子类不能重写
				父类方法是static 子类不存在重写
				父类方法是abstract 子类必须重写
				（子类是具体必须重写 否则子类是抽象类 可以不重写）
		4.返回值 子类可以小于等于父类           没有要求
		5.名字   子类与父类一致                 一个类中的好多方法必须一致
		6.参数   子类与父类一致					每一个方法的参数必须不一致（个数 类型 顺序）
		7.异常   运行时  编译时					没有要求
				 如果父类方法抛出运行时异常
				 子类可以不予理会
				 如果父类方法抛出编译时异常
				 子类抛出异常的个数少于等于父类
				 子类抛出的异常的类型小于等于父类
		8.方法体 子类的方法内容与父类不一致     每一个重载的方法 执行过程不一致
		
	每一个类都有一个继承类，如果不写extends关键字，默认继承Object，如果写了extends则继承后面那个父类
		Object类非常的重要 是任何一个引用类型的父类（直接或间接的继承Object）Object类没有父类
	
	
	Java中继承是单个存在的（单继承）每一个类只能有一个继承类（在extends关键字后面只能写一个类）
		可以通过传递的方式实现多继承的效果 后续还会有多实现
		
	继承在内存中的存储形式
	
	this(代替的是当前调用方法属性时的那个对象 不一定是当前类的对象)
	
	this和super关键字
		this和super都是指代词 代替的是对象
		this代替的是当前执行方法时的那个对象 不一定是当前类的对象
		super代替的是当前执行方法时的对象的父类对象 子类空间内部的那个父类对象
		都能调用一般属性和一般方法
		可以放置在类成员的任意位置（属性 方法  构造  块）
			注意调用一般方法的时候可以来回相互调用（编译好用）执行可能会产生问题（StackOverflowError)
		可以调用构造方法（放在构造方法的第一行）
			this和super在构造方法中调用另一个类的构造方法不能同时出现在第一行
			构造方法之间不能相互来回调用（编译不好用）
		
三目运算：
	(a>b)?x:y;
Object类中的方法：
	hashCode()	将对象在内存中的地址经过计算得到一个int整数
				public native int hashCode();
	equals()	用来比较两个对象的内容 Object默认效果是==
				==可以比较基本类型（比较值）可以比较引用类型（比较地址）
				equals方法是Object类中继承过来的方法 默认效果比较的是地址
				如果想要改变其规则 可以进行方法重写
				public boolean equals(Object obj){
					return (this == obj);
				}
	toString()	打印输出时将对象变成String字符串
				public String toString(){
					return getClass.getName()+"@"+Integer.toHexString(hashCode());
				}
	getClass()	获取对象对应类的类映射（反射）
	wait()		让线路进入挂起等待状态 存在方法重载
	notify()	线程唤醒
	notifyAll()	唤醒所有
	finalize()	权限修饰符是protected 在对象被GC回收的时候 默认调用执行的方法
	clone()		权限修饰符是protected 为了clone对象
	
	
类的关系
	has-a  包含关系（组合 聚合 关联）
	从亲密程度来讲不太一样(耦合程度)
		组合：人和大脑  人和心脏的关系
			整体和部分的关系 不可分割 要出现都出现 要消亡都消亡
		聚合：汽车和车轮子 电脑和主板
			整体和部分关系 创建时有可能是分开的
		关联：人有汽车 人有电脑
			整体和部分的关系 可以分割 后来形成在一起
		从java程序来描述这样的关系 通过一个类的对象当做另一个类的属性来存储
		
	use-a(need-a)  依赖关系
		屠夫 杀 猪
		一个类屠夫
			可以做一件事情  杀猪
			需要一头猪
		不是整体和部分的关系 某一件事情产生了关系 
		临时组合在一起 这件事情一旦做完关系即解散
		java中体现形式的行为：
			一个类的方法中使用到另一个类的对象
				第一个可以在方法中传递参数
				第二个可以在方法中自己创建
				
设计类的关系遵循的原则：高内聚低耦合
	耦合度：继承（实现）> 包含 > 依赖
		
	
修饰符：
	权限修饰符：
		public   公共的 					本类	同包	子类	外部
		protected  受保护的（最大子类可用）		本类	同包	子类
		默认不写   默认的（最大同包内可用）		本类	同包
		private    私有的（最大自己内部可用）	本类
		
		权限修饰符可以用来修饰  类本身  和类中的成员（除程序块）
		权限修饰符修饰类的时候只有两个可以用（public 默认不写）
		权限修饰符都可以用来修饰类中其他成员
		
	特征修饰符：
		final 最终的，不可更改的
		static 静态的
		abstract 抽象的
		native 本地的
		transient 瞬时的 短暂的  序列化
		synchronized 同步的 线程问题
		volatile 不稳定的
	
java类和类之间的关系
	继承 关联 依赖

java面向对象的四个特征
	继承 封装 多态 抽象
	
封装：将一些数据或者执行过程 进行一个包装
	目的：保护这些数据或执行过程的安全
		写登录流程 --》main 一段代码
		写登录方法 ---》login(name, pass)
		方法本身就算是封装 封装了执行的过程 保护过程的安全 隐藏了执行的细节 增强复用性
		多个方法和属性---》类
		对属性本身的封装：
			属性私有（封装在类中）
			提供操作属性的相应公有的方法
		强烈建议大家属性不要公有的---》非常的不安全
			
			
			
			
特征修饰符：final
	可以修饰什么？
	修饰以后有什么特点？
	final 最终的 不可更改的
	修饰变量 
		如果定义变量的时候没有赋初始值 给变量一次存值的机会（因为变量在栈内存中 没有默认值 如果不给机会 就没法用了）
		一旦变量被存储了一个值 若用final修饰后 则不让再次改变----》相当于常量了（值没法改变）
		注意变量类型是基本类型还是引用类型
		如果修饰的变量是基本数据类型 则变量内的值不让更改---常量
		如果修饰的变量是引用数据类型 则变量内的地址引用不让更改---对象唯一
	修饰属性：
		全局变量 存储在堆内存的对象空间内的一个空间
		普通属性没有赋初值 有默认值存在的
		属性用final修饰后 必须给属性赋初值 否则编译报错
		特点与修饰变量一致
		
		注意变量类型是基本类型还是引用类型
		如果修饰的变量是基本数据类型 则变量内的值不让更改---常量
		如果修饰的变量是引用数据类型 则变量内的地址引用不让更改---对象唯一
	修饰方法：
		方法是最终的 不可更改的
		子类继承父类的方法 将父类的方法重写
		final修饰的方法 要求不可以被子类重写
		
	修饰类：
		此类为final类 不可被子类继承
		通常是一些定义好的工具类
		Math Scanner Integer String 
		
		
特征修饰符：static 静态的
	可以修饰什么？
		修饰属性 修饰方法 修饰块 修饰类（内部类）
	修饰后有什么特点？
		1静态元素在类加载时就初始化了，创建的非常早，此时没有创建对象
		2静态元素存储在静态元素区中，每一个类有一个自己的区域，与别的类不冲突
		3静态元素只加载一次（只有一份），全部类的对象及类本身共享
		4由于静态元素区加载的时候，有可能没有创建对象，可以通过类名直接访问静态元素
		5可以理解为静态元素不属于任何一个对象，属于类的
		6内存管理 栈内存创建开始用完即回收 堆内存通过GC回收 静态元素区GC无法管理（可理解为常驻内存中）
		7非静态成员（堆内存对象里）中可以访问静态成员（静态区）
		8静态成员中可以正常访问静态成员（都在静态区中）
		9静态成员中不可以访问非静态成员（因为非静态成员有多个）（静态元素属于类）
		10静态元素中不可以出现this或super关键字（静态元素属于类）
	
多态：
	同一个对象 体现出来的多种不同形态（身份） 将一种行为表现出来不同的效果 要想实现多态的效果 需要先有继承关系
	
	体现：
		父类的引用 指向 子类的对象
		Person p = new Teacher();
		该引用只能调用父类中定义的属性或方法
		如果子类中将父类的方法重写，那么调取方法后执行的结果是子类重写之后的那个结果
			如果父类与子类有同名的属性 执行父类的属性
			如果父类与子类有同名的方法  执行子类重写之后的方法
			
		若想要调用子类中独有的成员
			强制类型转化 造型 铸型 向上/向下转型
		造型时（向下转型时） 可能会出现一个运行时的异常
			ClassCastException 造型异常
			如果想要避免造型的异常 可以用instanceof 关键字来进行判断 
			对象 instanceof 类
			InputMismatchException 输入不匹配
			NumberFormartExcetpion 数字格式化异常
			ArrayIndexOutOfBoundsException 数组索引越界
			NegativeArraySizeException 数组长度为负数
			NullPointerException 空指针异常
			ArithmeticException 算数异常
			ClassCastException 造型异常
			
			StackOverflowError 栈内存溢出错误
			
	
内部类：
	指的是在java中可以将一个类定义在另一个类的内部
	内部类可以定义在 类的内部（与类的成员层次一致）
	内部类可以定义在 方法/块内部（与类成员相差一个层次 方法的局部变量一个层次）
	
	1成员内部类
		将一个类直接定义在类的里面，作为成员，与属性或方法一个层次
		成员内部类和正常的类一样，可以用不同的修饰符来修饰。
		有什么好处：
			省略了一个源文件
			成员内部类中是可以访问所有的外部类成员，包括私有元素
			
			若要想在内部类中通过对象.调用外部类成员 外部类.this.外部类成员
			
			成员内部类存在后 源代码进行编译 产生一个字节码 Demo$InnerDemo.class
	2局部内部类
		将一个类定义在方法/块/构造方法里面，作为成员的内部结构，与临时的局部变量一个层次
		
		定义在不方法/块/构造方法里的局部内部类可以有相同的名字，Demo$1InnerDemo.class Demo$2InnerDemo.class
		局部内部类像是一个局部的变量一样，不能用正常的修饰符如public protected private 或 static
		只能用abstract或final
		局部内部类 编译 字节码定义好啦 由于变量的内容是可以改变的 所以要求编译的时候是什么样，执行之后还是什么样，因此局部内部类使用的局部变量必须是final修饰的
		
	3匿名内部类
	
		接口的实现直接去  new 接口名(){重写接口方法} 
		
		成员匿名内部类
		局部匿名内部类
		
		通常接口或抽象类的具体子类这样写
		开发中为了省略一个类文件 上述写法比常见
		匿名内部类很特殊 只有类体 没有类的所有结构（修饰符 名字 继承 实现）
		不能用任何修饰符来修饰 匿名内部类也没有构造方法
	4静态内部类
		static不能修饰局部变量
		只能是静态成员内部类
		不需要外部类对象，通过正常的方式直接创建内部类
		静态元素不能访问非静态成员
		
抽象类
	抽象类一般是用来描述事物的
	
	用abstract修饰的方法为抽象方法
	如果类中含有抽象方法，那么这个类必须是抽象类
	抽象类中可以没有抽象方法
	属性 可以含有一般的属性 也可以含有private static final 等
	方法 可以含有一般的属性 也可以含有private static final 等
		抽象类中允许含有抽象方法的
	块 可以含有一般的程序块 也可以含有static程序块
	构造方法 可以含有构造方法 可以重载
	抽象类是不能直接用构造方法构建对象的 
	抽象类含有构造方法 但是我们不能通过调用构造方法
	抽象类只能通过子类继承来做事
	抽象类---直接单继承---抽象类 可以
	抽象类---直接单继承---具体类 可以（一般不这么做）
	具体类---直接单继承---抽象类 不可以（需要将父类中的抽象方法具体化）
	

接口
	接口一般是描述一种规则的，定义规则

	接口中必须全部都是抽象方法，不用写abstract关键字
	接口中的属性默认就是 public static final 的常量
	这些关键字不写也是含有的
	
	方法 只能含有public的抽象方法（1.8 default修饰的具体方法）
	块  不能含有块static也不行
	构造方法 不能含有构造方法
	
	public class A implements B,C,D{}
	
	接口不能继承别的类 最抽象
	抽象类----直接多实现----接口  可以
	具体类----直接多实现----接口 不可以（必须将接口中的抽象方法具体化 或者自己变成抽象类）
	接口----多继承----接口   可以直接多实现
	
枚举
	一个类中的对象 认为个数是有限且固定的 可以将每一个对象一一列举出来
	jdk1.5之后可以直接定义enum类型
		我们自己定义的enum类型直接默认继承Enum(java.lang下的）
		我们自己定义的enum类型不能再写extends 但是可以实现接口
		Enum类型
			有两个属性
				name ---->枚举对象对应的名字 name()获取name属性
				ordinal --->枚举对象在类中罗列的顺序 类似index 也从0开始 ordinal()获取序号
			valueOf() 通过给定name获取对应的枚举对象
			values()  获取全部的枚举对象---->返回一个数组
			compareTo() 可以比较两个枚举对象 ordinal
			toString() 没有final可以被重写
		我们也可以在enum中描述自己的一些属性或方法
			必须在enum类中第一行描述一下枚举的样子 且分号结束
			 Monday(1), Tuesday(2), Wednesday(3), Thursday(4), Friday(5), Saturday(6), Sunday(7);
			 类创建的过程中 帮我们创建枚举类型的对象
			 需要给枚举类型提供对应样子的private的构造方法