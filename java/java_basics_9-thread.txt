程序
    可以理解为一组静态的代码
进程
    正在进行的程序  静态的代码 运行起来
线程
    正在执行程序中的小单元

线程分类
    1。主线程  系统线程
    2。用户线程  main
    3。守护线程（精灵） gc

线程-------操作系统级别 CPU来调度

线程状态
    创建线程--------就绪状态--------执行状态--------等待/挂起--------异常/死亡
    线程的状态在Thread.Stat这个Enum中定义的有：NEW RUNNABLE TERMINATED WAITING TIMED_WAITING BLOCKED，可以通过 getState获取

实现线程的过程
    自己描述一个类
    继承父类Thread
    重写run方法
    new一个线程对象，调用start()方法让线程进入就绪状态

    自己描述一个类
    实现Runnable接口
    重写run方法
    new一个线程（Thread）对象，把Runnable对象传进去，调用start()方法让线程进入就绪状态


集合特性：
利用Vector集合 集合本身就是线程安全的
    1 如何切换线程的不同状态
    2 如果在设计中没有集合 我们自己想要控制线程安全

线程安全问题：
    synchronized 特征修饰符 同步的
    线程锁 锁定的是对象
    1 放置在方法的结构上
    public synchronized void test(){
        ...
    }
    当 对象.test();调用的时候 对象被某一个访问他的线程锁定

    2 放置在方法（构造 块）的内部（看起来是包含着一堆代码）
    public void test() {
        synchronized(对象){
            ...
        }
    }

线程相关的一些方法：
  Thread类
    sleep();
    run();
    start();
    setPriority(); 1~10
    join();//让两个并行的线程合成一条线程 看源码

  Object类
    wait();
    notify();
    notifyAll();

    注意wait方法 notify方法 使用
    对象.wait();
    对象调用wait方法 不是对象等待
    而是访问此对象的线程进入等待状态



JAVA多线程进阶篇

一 Java世界中的线程
    1 进程 线程 任务
    2 多线程编程介绍
    3 java线程api简介
    4 无处不在的线程
    5 线程的层次关系
    6 线程的生命周期状态
    7 线程的监视
    8 多线程编程简单运用实例
    9 多线程编程的优势与风险

二 多线程编程的目标与挑战
    1 串行 并发 并行
    2 竞态
        计算结果的正确性与时间有关那么就有了竞态
    3 线程安全性
        程序（java中的类）是不是据有线程安全性
        是不是会导致竞态
    4 原子性
        一个操作如果从其执行线程以外的任意线程来看是不可分割的
        锁: 锁是软件层面实现的
        CAS: compare and swap 是直接在硬件（内存和CPU）这一层来实现的
        volatile关键字修饰变量可以使变量据有写操作的原子性
    5 可见性
        一个线程对共享变量的更新是否能够被其他线程感知
    6 有序性
        重排序：指令重排序，存储子系统重排序
    7 上下文切换
        线程数量大于cpu核数
    8 线程的活性故障
        线程一直处于RUNNABLE状态，但是他要执行的任务却一直无法进展：
        死锁  永远在非RUNNABLE状态
        锁死  被锁需要某个特定的条件来开启
        活锁  在做无用功，如猫追自己的尾巴
        饥饿  无法获得执行的资源
    9 资源争用与调度
        理想：高并发 低争用

     如果每个线程任务用时比较长且对时间偏差有所要求的情况下用公平调度策略：吞吐小，不会出现线程饥饿
     如果对线程任务用时较短且对时间偏差没有要求的情况下使用非公平调度策略：吞吐大，线程任务用时偏差大，会出现线程饥饿
